#!/usr/bin/env python2
# even though this isn't executable code, above line required to prevent
# linting for Python 3

"""
Resilient connection to a backend DB. Automatically recreates the connection
if the backend is restarted.

Copyright (c) 2016-present, Facebook, Inc.
All rights reserved.

This source code is licensed under the BSD-style license found in the
LICENSE file in the root directory of this source tree. An additional grant
of patent rights can be found in the PATENTS file in the same directory.
"""

import abc
from sys import exc_info
from traceback import format_exc


class ConnectorAbort(BaseException):
    """
    Abort a transaction.
    """
    pass


class ConnectorError(Exception):
    """
    The connector was unable to complete a transaction within a certain
    number of attempts.
    """
    pass


class DatabaseError(Exception):
    """
    Wrap errors raised by the underlying db so that they can be caught
    by a client without the client needing to know the db-specific type.
    """
    def __init__(self, inner, msg="db error"):

        if inner:
            msg = ("%s - %s(%s): %s" %
                   (msg,
                    inner.__class__.__name__,
                    inner,
                    format_exc()))
        super(DatabaseError, self).__init__(msg)


class BaseConnector(object, metaclass=abc.ABCMeta):
    """
    BaseConnector represents a connection to the database that may be
    recreated without user impact if, say, the database is restarted.
    """

    def __init__(self, retry_limit=5):

        self._connection = None
        self._retry_limit = retry_limit
        # Attempt to connect to the db
        try:
            self.connect()
        except Exception as ex:
            raise DatabaseError(ex, "unable to connect to db")

    @abc.abstractmethod
    def connect(self):
        """
        Create a new connection to the underlying db. Must be implemented
        by concrete subclasses.
        """
        pass

    def execute(self, txn, *args):
        """
        Execute the caller-provided transaction function with the current
        db connection object as an argument. The connection context will
        already be opened, i.e., a new transaction will have begun. 'args'
        is just a passthrough for convenience (testing, maybe other places).

        If the transaction terminates due to an exception defined as one
        of the db_restart_errors types then a new connection will be created
        and the transaction function re-executed.

        Once the transaction function terminates normally the context will
        be closed, committing the transaction, and the return value of the
        transaction function will be returned to the caller of this function.
        """
        attempts = 0
        while self._retry_limit >= 0 and attempts <= self._retry_limit:
            try:
                if not self._connection:
                    self.connect()
                with self._connection as conn:
                    return txn(conn, *args)
            except ConnectorAbort:
                # transaction was terminated explicitly - no error
                return None
            except self.db_restart_errors as ex:
                # those are the exception types we take as indicating that
                # we need to reconnect to the server
                self._connection = None
                attempts += 1
            except self.db_errors as ex:
                # these exceptions should be wrapped
                raise DatabaseError(ex)
        raise ConnectorError("Unable to complete transaction (%d attempts)" %
                             attempts)

    def exec_and_fetch(self, stmt, *args):
        """
        Execute a single SQL statement, fetch all rows created as a result
        of that statement. Will cause an error if the statement did not
        generate any results.
        """
        def worker(cur):
            cur.execute(stmt, *args)
            return cur.fetchall()
        return self.with_cursor(worker)

    def exec_and_fetch_one(self, stmt, *args):
        """
        Execute a single statement, fetch a single row. Raises TypeError
        if multiple rows returned, IndexError if no row returned.
        """
        ret = self.exec_and_get_option(stmt, *args)
        if ret:
            return ret
        raise IndexError("no value generated by '%s'" % (stmt, ))

    def exec_and_get_option(self, stmt, *args):
        """
        Execute a single statement, fetch a single row if one was returned.
        Raises TypeError if multiple rows were returned.
        """
        ret = self.exec_and_fetch(stmt, *args)
        if ret:
            if len(ret) > 1:
                raise TypeError("multiple rows where one expected")
        return ret[0] if ret else ret

    def exec_stmt(self, stmt, *args):
        """
        Execute a single statement, return nothing.
        """
        return self.with_cursor(lambda cur: cur.execute(stmt, *args))

    def with_cursor(self, txn, *args):
        """
        Essentially the same as execute() above but passes a cursor object
        to the transaction function rather than the connection object. For
        most clients this is more appropriate, since multiple cursors are
        not generally needed.
        """
        def worker(conn):
            with conn.cursor() as cur:
                return txn(cur, *args)
        return self.execute(worker)
